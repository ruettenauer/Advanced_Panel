---
title: "Panel Data Estimators 1"
author: "Tobias RÃ¼ttenauer"
format: 
  revealjs:
    scrollable: true
    footer: <[Home](/index.html)> 
---

\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\tr}{\mathrm{tr}}
\newcommand{\plim}{\operatornamewithlimits{plim}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\E}{\mathrm{E}}
\newcommand{\Prob}{\mathrm{Prob}}
\newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}

```{r setup, cache=FALSE, include=FALSE}
# options(htmltools.dir.version = FALSE)
# library(knitr)
# opts_chunk$set(
#   fig.align="center",  
#   fig.height=4, #fig.width=6,
#   # out.width="748px", #out.length="520.75px",
#   dpi=300, #fig.path='Figs/',
#   cache=T#, echo=F, warning=F, message=F
#   )
library(tidyverse)
library(hrbrthemes)
library(fontawesome)
library(plm)
library(lfe)
library(texreg)
library(viridis)
```

# Variance Decomposition

## Age and happiness {.scrollable}

Let's clarify the idea and advantage of panel data with an example. 

Assume we want to know the relationship between age (as our independent variable) and happiness (as our dependent variable), and we have data on 24 observations.


```{r simulate}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
################################
### Example 1: Age happiness ###
################################

set.seed(213)

### Data simulation program
simdata <- function(N = 6, T = 4,
                    age_range = c(20:60), 
                    u_sd = 0.2, uw_sd = 0){
  
  # id and wave
  df <- data.frame(matrix(NA, ncol = 2, nrow = N*T))
  names(df) <- c("id", "time")
  
  df$id <- rep(1:N, each = T)
  df$time <- rep(1:T, times = N)
  df$idname <- factor(df$id, levels = c(1:N), labels = paste("Person", c(1:N)))
  
  # age
  startingage <- age_range
  startingage <- round(quantile(startingage, probs = seq(0, 1, 1/(N-1))), 0)
  df$age <- unname(rep(startingage, each = T)) + df$time*2
  
  # cohort 
  df$cohort <- 0
  df$cohort[(N*T/2 + 1):(N*T)] <- 1
  df$cohort <- factor(df$cohort, levels = c(0, 1), 
                      labels = c("Younger cohort", "Older cohort"))
  
  # demeaned age
  df$dm_age <- df$age - ave(df$age, df$id, FUN = function(x) mean(x)) 
  
  # Personal intercept
  df$intercept <- 5 + 0.5 * df$id
  
  # Overall error
  u <- rnorm(N*T, mean = 0, sd = u_sd)
  
  # Additional within error
  uw <- unlist(lapply(1:N, function(x) rnorm(T, mean = 0, sd = uw_sd)))
  
  # Gen happiness
  y <- 1 + 0.05 * df$age - 0.2 * df$dm_age + 2 * as.numeric(df$cohort) + u + uw
  df$happiness <- y
  
  # Gen person means
  df$m_age <- ave(df$age, df$id, FUN = function(x) mean(x)) 
  df$m_happiness <- ave(df$happiness, df$id, FUN = function(x) mean(x)) 
  
  return(df)
}

### Set up six individuals with age and happiness
N <- 6
T <- 4

df <- simdata(N = N, T = T)


# Total line for plot
lm1 <- lm(happiness ~ age, data = df)
lm2 <- lm(happiness ~ age + cohort, data = df)
lm3 <- lm(happiness ~ age + idname, data = df)
lm4 <- lm(m_happiness ~ m_age, data = df)
```


## Age and happiness

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
zp0 <- ggplot(df, aes(age, happiness)) +
  geom_point( aes(x = age, y = happiness), size = 2, stroke = 1) +
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  theme_classic() +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.95,0.05), legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))
zp0  
```


## Cross-sectional setting

In a cross-sectional setting, we could just run a standard linear regression model using Omitted Least Squares (OLS) of the form

$$
y_{i} = \alpha + \beta_1 x_{i} + \upsilon_{i},
$$

where $y_{i}$ is the dependent variable (happiness) and $x_i$ the independent variable of each observation $i \in \{1, \dots, 24\}$. $\beta_1$ is the coefficient of interest, $\alpha$ the overall intercept and $\upsilon_{i}$ the error term.

## Cross-sectional setting

```{r}
lm1 <- lm(happiness ~ age, data = df)
summary(lm1)
```

## Cross-sectional setting 

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
# The palette with black:
cbp2 <- c("#000000", 
          "#E69F00", 
          "#56B4E9", 
          "#009E73",
          "#F0E442", 
          "#0072B2", 
          "#D55E00", 
          "#CC79A7")

# Save the residual values
df$predicted <- predict(lm1)
df$residuals <- residuals(lm1)

zp1 <- ggplot(df, aes(age, happiness)) +
  geom_point( aes(x = age, y = happiness), size = 2, stroke = 1) +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE, color  = "deeppink") +
  geom_segment(data = df, aes(xend = age, yend = predicted), 
               alpha = .3, color = "purple") +
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  theme_classic() +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.95,0.05), legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))
zp1  
```


## Adding controls

Birth cohort might be a potential confounder that affects age and happiness. We would then estimate the model  

$$
y_{i} = \alpha + \beta_1 x_{i} + \beta_2 z_{it} + \upsilon_{i},
$$

where $z_i$ is the control variable or confounder (cohort).

## Adding controls

```{r}
lm2 <- lm(happiness ~ age + cohort, data = df)
summary(lm2)
```

## Adding controls

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
# Save the residual values
for(i in unique(df$cohort)){
  oo <- which(df$cohort == i)
  lmt <- lm(happiness ~ age, data = df[oo, ])
  df$predicted[oo] <- predict(lmt)
  df$residuals[oo] <- residuals(lmt)
}


zp2 <- ggplot(df, aes(age, happiness)) +
  geom_point(aes(x = age, y = happiness, shape = cohort, colour = cohort), 
              size = 2, stroke = 1) +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE, show.legend = FALSE,
              mapping = aes(colour = cohort, linetype = cohort)) +  
  geom_segment(data = df, aes(xend = age, yend = predicted), 
               alpha = .3, color = "purple") +
  geom_abline(intercept = lm2$coefficients[1] + 0.5 * lm2$coefficients[3], 
                               slope = lm2$coefficients[2], color  = "deeppink") +  
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_fill_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  theme_classic() +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.95,0.05), legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))
zp2  
```


## Panel data setting {.smaller}

Now, with panel data, we can even go a step further. Assume we would not have observed 24 independent observations, but rather 6 independent individuals (N = 6) at 4 time-points each (T = 4). 

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
zp3 <- ggplot(df, aes(age, happiness)) +
  geom_point( aes(x = age, y = happiness, shape = idname, colour = idname, fill = idname), 
              size = 2, stroke = 1) +
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_fill_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  theme_classic() +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.95,0.05), legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))
zp3 
```

## Panel data setting

We can then decompose the available variance into three different parts:

* **Pooled** variance

* **Between** variance

* **Within** variance



## Pooled estimator

The pooled estimator equals what we have seen in the cross-sectional example: we basically assume that we have 24 independent observations and we ignore the person and time dimension. The Pooled OLS estimator is simply:

$$
y_{it} = \alpha + \beta_{POLS} x_{it} + \upsilon_{it},
$$

```{r}
#| echo: true
#| output: false
lm1 <- lm(happiness ~ age, data = df)
summary(lm1)
```


## Pooled estimator

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
# Save the residual values
df$predicted <- predict(lm1)
df$residuals <- residuals(lm1)

zp3 <- ggplot(df, aes(age, happiness)) +
  geom_point( aes(x = age, y = happiness, shape = idname, colour = idname, fill = idname), 
              size = 2, stroke = 1) +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE,
              color  = "deeppink") +
  geom_segment(aes(xend = age, yend = predicted), 
               alpha = .3, color = "purple") +
  annotate("text", x = 35, y = 8.0, 
           label = paste0("beta[Pooled] ==", round(lm1$coefficients[2], 3)), 
           parse = TRUE) +
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_fill_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  ggtitle("A) Pooled Estimate") +
  theme_classic() +
  theme(legend.key = element_blank(), 
        legend.title = element_blank(),
        text = element_text(size = 14),
        legend.position = c(0.95,0.05), 
        legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))
zp3
```


## Between estimator

The between estimator only compares different persons and discards the within-person variance. Therefore, we simply run a model that only uses the person-specific means

$$
\bar{y_{i}} = \alpha + \beta_{BTW} \bar{x_{i}} + \bar{\upsilon_{i}},
$$

where $\bar{y_{i}}$ and $\bar{x_{i}}$ are the unit-specific means of $x_{it}$ and $y_{it}$, respectively.



## Between estimator

We can either estimate this by hand:

```{r}
#| echo: true
#| output: false
df$m_happiness <- ave(df$happiness, df$id, FUN = mean)
df$m_age <- ave(df$age, df$id, FUN = mean)

lm2 <- lm(m_happiness ~ m_age, data = df)
summary(lm2)
```




## Between estimator

or we use the `plm` package to do the job for us

```{r}
btw2 <- plm(happiness ~ age, data = df,
           index = c("id", "time"),
           effect = "individual", model = "between")
summary(btw2)
```



## Between estimator


```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
df2 <- df
df2$happiness <- df2$m_happiness
df2$age <- df2$m_age
df2 <- df2[which(df2$time == 1), ]

# Save the residual values
lm4 <- lm(m_happiness ~ m_age, data = df2)
df2$predicted <- predict(lm4)
df2$residuals <- residuals(lm4)

zp4 <- ggplot(df, aes(age, happiness)) +
  geom_point(aes(x = age, y = happiness, shape = idname), 
              size = 2, stroke = 1, colour = alpha("black", .3), fill = alpha("black", .3)) +
  geom_point(aes(x = m_age, y = m_happiness, shape = idname, colour = idname,
                 fill = idname), 
             size = 2, stroke = 1) +
  geom_smooth(data = df2, 
              method = 'lm', formula = y ~ x, se = FALSE,
              color  = "deeppink") +
  geom_segment(data = df2, aes(xend = age, yend = predicted), 
               alpha = .3, color = "purple") +
  annotate("text", x = 35, y = 8.0, 
           label = paste0("beta[Between] ==", round(lm4$coefficients[2], 3)), 
           parse = TRUE) +
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_fill_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  ggtitle("B) Between Estimate") +
  theme_classic() +
  theme(legend.key = element_blank(), 
        legend.title = element_blank(),
        text = element_text(size = 14),
        legend.position = c(0.95,0.05), 
        legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))

zp4  
```



## Within estimator

The within estimator only compares different periods within the same person and discards the between-person variance. We could also say the estimator is solely based on changes over time. 

$$
y_{it} = \alpha_i + \beta_{WI} x_{it} + \epsilon_{it},
$$

To achieve this, we simply give every person their own intercept $\alpha_i$: we add a dummy for each person.

## Within estimator

Again, we could run this manually

```{r}
#| echo: true
#| output: false
lm3 <- lm(happiness ~ age + idname, data = df)
summary(lm3)
```

Make sure idname is a factor. Otherwise use `as.factor(idname)`.


## Within estimator

or we use `plm`:

```{r}
#| eval: FALSE
#| code-line-numbers: "1"
fe1 <- plm(happiness ~ age, data = df,
           index = c("id", "time"),
           effect = "individual", model = "within")
summary(fe1)
```

* Formula and Data

## Within estimator

or we use `plm`:

```{r}
#| eval: FALSE
#| code-line-numbers: "2"
fe1 <- plm(happiness ~ age, data = df,
           index = c("id", "time"),
           effect = "individual", model = "within")
summary(fe1)
```

* Define id and time columns

## Within estimator

or we use `plm`:

```{r}
#| eval: FALSE
#| code-line-numbers: "3"
fe1 <- plm(happiness ~ age, data = df,
           index = c("id", "time"),
           effect = "individual", model = "within")
summary(fe1)
```

* effect: Define the type of fixed effects (`individual`, `time`, `twoways`)

* model: Define the estimator (`within` for FE)



## Within estimator

or we use `plm`:

```{r}
#| eval: TRUE
#| code-line-numbers: "4"
fe1 <- plm(happiness ~ age, data = df,
           index = c("id", "time"),
           effect = "individual", model = "within")
summary(fe1)
```


## Within estimator


```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
df2 <- df
df2$happiness <- df2$happiness - df2$m_happiness + mean(df$happiness)
df2$age <- df2$age - df2$m_age  + mean(df$age)

# Save the residual values
for(i in unique(df$id)){
  oo <- which(df$id == i)
  lmt <- lm(happiness ~ age, data = df[oo, ])
  df$predicted[oo] <- predict(lmt)
  df$residuals[oo] <- residuals(lmt)
}


zp5 <- ggplot(df, aes(age, happiness)) +
  geom_point( aes(x = age, y = happiness, shape = idname, colour = idname, fill  = idname), 
              size = 2, stroke = 1) +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE, show.legend = FALSE,
              mapping = aes(group = idname),
              color  = "deeppink", linetype = "dotted") +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE, show.legend = FALSE,
              data = df2, color  = "deeppink", fullrange = TRUE) +
  geom_segment(data = df, aes(xend = age, yend = predicted), 
               alpha = .3, color = "purple") +
  annotate("text", x = 35, y = 8.0, 
           label = paste0("beta[Within] ==", round(lm3$coefficients[2], 3)), 
           parse = TRUE) +
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  scale_fill_manual(values = cbp2[-c(1, 2)]) +
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  ggtitle("C) Within Estimate / Fixed Effects") +
  theme_classic() +
  theme(legend.key = element_blank(), 
        legend.title = element_blank(),
        text = element_text(size = 14),
        legend.position = c(0.95,0.05), 
        legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"))

zp5
```


## Comparison

```{r}
library("texreg")
screenreg(list(lm1, lm2, lm3), digits = 3, 
          custom.model.names = c("POLS", "Between", "Within"))
```



## Comparison

![](fig/Decomposition.jpeg)


## FE: Faster estimation

Often faster than `plm`: `felm()` in package `lfe`

Particularly, with large data, group-specific interactions, or when you want clustered standard error, this can save you time.



## FE: Faster estimation

Often faster than `plm`: `felm()` in package `lfe`

```{r}
#| eval: false
#| code-line-numbers: "2"
library(lfe)
fe1_alt <- felm(happiness ~ age | id | 0 | id,
                data = df)
summary(fe1_alt)
```

Four-part formula:

* Formula: 1) ordinary covariates, 2) fixed effects, 3) Instrumental Variables, 4) Cluster for SEs

* y ~ x1 + x2 | f1 + f2 | (Q|W ~ x3+x4) | clu1 + clu2

* Can include interactions between FEs: y ~ x1 + x | x:f + f



## FE: Faster estimation

Often faster than `plm`: `felm()` in package `lfe`

```{r}
#| eval: TRUE
#| code-line-numbers: "4"
library(lfe)
fe1_alt <- felm(happiness ~ age | id | 0 | id,
                data = df)
summary(fe1_alt)
```





# Fixed Effects

## Assumption for conistency of POLS

### The POLS

$$
y_{it} = \alpha + \beta x_{it} + \upsilon_{it}
$$

relies on very strong assumptions for consistency, most importantly: The error (including omitted variables) must not be correlated with $x_{it}$.

* $\E(\upsilon_{it} | x_{it}) = 0$, or $Cov(x_{it}, \upsilon_{it}) = 0$


## Marriage and income

Imagine we want to know how getting married affects a persons happiness or their income. POLS (and the between estimator) compare people who eventually get married to people who never get married.

What could potentially go wrong?


## One-way fixed effects

To relax the strong assumption, we can decompose the error into two parts (between and within) and split up our main assumption for consistency:

* $\E(\alpha_{i} | x_{it}) = 0$: No time-constant unobserved heterogeneity

* $\E(\epsilon_{it} | x_{it}) = 0$: No time-varying unobserved heterogeneity



## One-way fixed effects

### The FE 

$$
y_{it} = \beta x_{it} + \alpha_i + \epsilon_{it}
$$

includes unit-specific fixed effects to account for the first type of heterogeneity. The most basic way of including person-specific dummy variable is called Least Square Dummy variable (LSDV) approach.

See e.g. @Wooldridge.2010 or Bruderl.2015.



## One-way fixed effects

In practice, we usually use a transformation approach, where we first subtract the between variance by using use the person-specific means:

$$
\begin{split}
y_{it} - \bar{y_{i}} &= \beta (x_{it}-\bar{x_{i}}) + (\alpha_i - \alpha_i) + (\epsilon_{it}-\bar{\epsilon_{i}})\\
\tilde{y}_{it} &= \beta \tilde{x}_{it} + \tilde{\epsilon}_{it}.
\end{split}
$$

## One-way fixed effects

The main assumption for consistency now is

* $\E(\epsilon_{it} | x_{it}, \alpha_i) = 0$

Idiosyncratic time-variation in $\epsilon_{it}$ (**including time trends in $y$**) must be uncorrelated with variation in $x_{it}$ across all time periods. However, $\E(\alpha_{i} | x_{i})$ can be any function of $x_i$.

* Time-constant unobserved heterogeneity is allowed

* Only time-varying unobserved heterogeneity biases the estimator




## Would one-way FE get it right?


```{r setup2}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
##################################
### Example 2: Marriage Income ###
##################################

### Set up six individuals with age and happiness
N <- 4
T <- 6

# id and wave
df2 <- data.frame(matrix(NA, ncol = 2, nrow = N*T))
names(df2) <- c("id", "time")

df2$id <- rep(1:N, each = T)
df2$time <- rep(1:T, times = N)
df2$idname <- factor(df2$id, levels = c(1:N), labels = paste("Person", c(1:N)))

# Marriage dummy
df2$marriage_ever <- 0 
df2$marriage_ever[(N*T/2 + 1):(N*T)] <- 1

df2$marriage <- df2$marriage_ever * ifelse(df2$time >= 4, 1, 0)

# Starting wage
stw <- c(2000, 5000)
stw <- round(quantile(stw, probs = seq(0, 1, 1/(N-1))), 0)

# wage equation
df2$wage <- unname(rep(stw, each = T)) + (df2$time - 1)*50 + 200 * ifelse(df2$time >=4, 1, 0) + df2$marriage * 500

# counterfactual parallel trend
df2$pti <- unname(rep(stw, each = T)) + (df2$time - 1)*50 
df2$pt <- unname(rep(stw, each = T)) + (df2$time - 1)*50 + 200 * ifelse(df2$time >=4, 1, 0) 
df2$pti[df2$marriage_ever == 0 | df2$time < 3] <- NA
df2$pt[df2$marriage_ever == 0 | df2$time < 3] <- NA


### Add individual slope / heterogeneous time trends

# wage equation
df2$wage2 <- unname(rep(stw, each = T)) + (df2$time - 1)*50  + (df2$time - 1)*150*df2$marriage_ever + 200 * ifelse(df2$time >=4, 1, 0) + df2$marriage * 500

# parallel trend
df2$pt2 <- unname(rep(stw, each = T)) + (df2$time - 1)*50 + 200 * ifelse(df2$time >=4, 1, 0) + 2*150
df2$pt2[df2$marriage_ever == 0 | df2$time < 3] <- NA

# actual trend
df2$pt2_cr <- unname(rep(stw, each = T)) + (df2$time - 1)*50 + (df2$time - 1)*150*df2$marriage_ever + 200 * ifelse(df2$time >=4, 1, 0)
df2$pt2_cr[df2$marriage_ever == 0 | df2$time < 3] <- NA

# Marry to factor
df2$marriage <- factor(df2$marriage, levels = c(0, 1), labels = c("not married", "married"))
df2$marriage_ever <- as.factor(df2$marriage_ever)


### Plot 
zp1 <- ggplot(df2, aes(time, wage)) +
  geom_line(aes(x = time, y = wage, group = id), lty = "solid", colour = "black", lwd = 1) + 
  geom_point( aes(x = time, y = wage, shape = marriage, fill = marriage), 
             size = 4, stroke = 1.5, color = "white") +
  theme_classic() +
  scale_shape_manual(values = c(21, 24)) +
  scale_fill_manual(values = c("#85144b", "#0074D9")) +
  scale_color_manual(values = c("#85144b", "#0074D9")) +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.05,0.95), legend.justification = c("left", "top"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"),
        legend.spacing.y = unit(-0.1, "cm"))
zp1 

```


## Would one-way FE get it right?

```{r}
fe2 <- plm(wage ~ marriage, data = df2,
           index = c("id", "time"),
           effect = "individual", model = "within")
summary(fe2)
```


## Would one-way FE get it right?

FE is based on within-unit variance.

::: {.callout-note}
A one-ways FE would effectively drop all those observations without within-variance on the independent variables. In our case, we would disregard those who never marry. 
:::

However, the never married also experienced an increase in wages when the other two married.



## Would one-way FE get it right?

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
### Plot 
zp3 <- ggplot(df2, aes(time, wage)) +
  geom_line(aes(x = time, y = wage, group = id, alpha = marriage_ever), lty = "solid", colour = "black", lwd = 1) + 
  geom_point( aes(x = time, y = wage, shape = marriage, fill = marriage, alpha = marriage_ever), 
              size = 4, stroke = 1.5, color = "white") +
  geom_line(aes(x = time, y = pti, group = id, linetype = "dashed"), colour = "blue", lwd = 1) +
  scale_linetype_identity(labels = "Counterfactual", guide = "legend") +
  scale_alpha_manual(values = c(0.5, 1), guide = "none") +
  # geom_mark_hull(data = df2[df2$marriage_ever == 1, ], aes(x = time, y = wage, fill = marriage),
  #                expand = 0.01, show.legend = FALSE, colour = NA) + 
  theme_classic() +
  scale_shape_manual(values = c(21, 24)) +
  scale_fill_manual(values = c("#85144b", "#0074D9")) +
  scale_color_manual(values = c("#85144b", "#0074D9")) +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.05,0.95), legend.justification = c("left", "top"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"),
        legend.spacing.y = unit(-0.1, "cm"))
zp3
```


## Two-ways FE

To circumvent the problem above, we want to add the never-married as a control group in our estimator. 

::: {.callout-tip}
__In general, it is always a good idea to control for temporal shocks!__
:::


## Two-ways FE

### The two-way FE

$$
y_{it} = \beta x_{it} + \alpha_i + \zeta_t + \epsilon_{it},
$$

adds $\zeta_t$, with are time fixed effects. Analogous to $\alpha_i$, we could just add a dummy variable for each year / time period in the data.

This removes common time shocks independent of treatment, and takes back in individuals without variation in $x$. We basically add a 'control-group' to the estimation.


## Two-ways FE

In practice, we usually use a transformation approach, where we subtract the between variance by using the person-specific & time-specific means:

$$
\begin{split}
(y_{it} - \bar{y}_i  - \bar{y}_t + \bar{y}) = \beta (x_{it} - \bar{x}_i - \bar{x}_t + \bar{x}) \\ + (\epsilon_{it} - \bar{\epsilon}_i  - \bar{\epsilon}_t + \bar{\epsilon}).
\end{split}
$$


## Two-ways FE

We can just change the `effect` option in `plm` to "twoways" to achieve this:

```{r}
#| eval: TRUE
#| code-line-numbers: "3"
#| output: false
fe3 <- plm(wage ~ marriage, data = df2,
           index = c("id", "time"),
           effect = "twoways", model = "within")
summary(fe3)
```

## Two-ways FE

Or we add another factor variable in `felm':

```{r}
#| eval: TRUE
#| code-line-numbers: "1"
fe3_alt <- felm(wage ~ marriage | id + as.factor(time) | 0 | id,
                data = df2)
summary(fe3_alt)
```

## Two-ways FE

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
### Plot 
zp4 <- ggplot(df2, aes(time, wage)) +
  geom_line(aes(x = time, y = wage, group = id), lty = "solid", colour = "black", lwd = 1) + 
  geom_point( aes(x = time, y = wage, shape = marriage, fill = marriage), 
              size = 4, stroke = 1.5, color = "white") +
  geom_line(aes(x = time, y = pt, group = id, linetype = "dashed"), colour = "blue", lwd = 1) +
  scale_linetype_identity(labels = "Counterfactual", guide = "legend") +
  theme_classic() +
  scale_shape_manual(values = c(21, 24)) +
  scale_fill_manual(values = c("#85144b", "#0074D9")) +
  scale_color_manual(values = c("#85144b", "#0074D9")) +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.05,0.95), legend.justification = c("left", "top"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"),
        legend.spacing.y = unit(-0.1, "cm"))
zp4
```

## A very critical assumption

In the example above, the twoways FE model works very well. However, adding the control group back in comes with a strong assumption:

__Parallel trends between "treatment" and "control" units__

Comparing the 3 waves before the treatment above, this assumption here holds. Both - those who marry and those who never marry - have the same time trend in wages before the "treated" marry.

## A very critical assumption

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
zp5 <- ggplot(df2, aes(time, wage2)) +
  geom_line(aes(x = time, y = wage2, group = id), lty = "solid", colour = "black", lwd = 1) + 
  geom_point( aes(x = time, y = wage2, shape = marriage, fill = marriage), 
              size = 4, stroke = 1.5, color = "white") +
  # geom_line(aes(x = time, y = pt2, group = id, linetype = "dashed"), colour = "blue", lwd = 1) +
  # geom_line(aes(x = time, y = pt2_cr, group = id, linetype = "dashed"), colour = "grey", lwd = 1, show.legend = FALSE, alpha = 0.7) +
  scale_linetype_identity(labels = "Counterfactual", guide = "legend") +
  # scale_alpha_manual(values = c(0.3, 1), guide = "none") +
  # ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  theme_classic() +
  scale_shape_manual(values = c(21, 24)) +
  scale_fill_manual(values = c("#85144b", "#0074D9")) +
  scale_color_manual(values = c("#85144b", "#0074D9")) +
  ylab("wage") +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.05,0.95), legend.justification = c("left", "top"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"),
        legend.spacing.y = unit(-0.1, "cm"))
zp5
```

## A very critical assumption

```{r}
fe3 <- plm(wage2 ~ marriage, data = df2,
           index = c("id", "time"),
           effect = "twoways", model = "within")
summary(fe3)
```





# Difference in Differences

## Difference in Differences

The difference-in-differences (DD) design is a very basic and popular design to identify causal treatment effects in a panel data setting. 

The most basic setting, is a $2\times 2$ DD estimator. It consists of a setting where we have 2 groups: a treatment group ($T$) and control group ($C$). Each group has been observed at 2 time points: before treatment ($pre$) and after treatment ($post$).

See @Cunningham.2021 and @Huntington-Klein.2021.

## Difference in Differences {.smaller}

In this setting we can calculate the change in the treatment group:
$$
\E(\Delta y_{T}) = \E(y_{T}^{post}) - \E(y_{T}^{pre}),
$$

and likewise in the control group:
$$
\E(\Delta y_{C}) = \E(y_{C}^{post}) - \E(y_{C}^{pre}).
$$

The simple DD estimator is then the difference between the differences in the treatment group and the differences in the control group:

$$
\hat{\delta}_{DD} = \E(\Delta y_{T}) - \E(\Delta y_{C}) = (\E(y_{T}^{post}) - \E(y_{T}^{pre})) - (\E(y_{C}^{post}) - \E(y_{C}^{pre})).
$$



## Difference in Differences

![Diff-in-Diff design, adopted from @Cunningham.2021](fig/dd-diagram-1.png)



## Difference in Differences

### The DID

$$
y_{it} = \alpha + \gamma D_{i} + \lambda Post_{t} + \delta_{DD} (D_{i} \times Post_{t}) + \upsilon_{it}.
$$

is the same estimator in a simple regression, $D \in {0, 1}$ is a binary indicator of the treatment group and $Post \in {0, 1}$ a binary indicator of pre- or post-treatment period.

## Difference in Differences

### The DID {.smaller}
 
$$
y_{it} = \alpha + \gamma D_{i} + \lambda Post_{t} + \delta_{DD} (D_{i} \times Post_{t}) + \upsilon_{it}.
$$

* $\alpha$: average outcome of control group in pre-treatment period 

* $\gamma$: average difference between treatment and control group in pre-treatment period 

* $\lambda$: average difference between post- pre-treatment period in control group

* $\delta_{DD}$: difference between treatment and control group in difference between post- pre-treatment period



## Difference in Differences


```{r}
df2$marry_post <- 0
df2$marry_post[df2$time >= 4] <- 1

did1 <- lm(wage ~ marriage_ever*marry_post, data = df2)
summary(did1)
```



## Difference in Differences

In a setting where $T=2$ or in a setting where every observation is treated at the same time, the DD equals the two-ways FE. 

In general, DD and two-ways DD are often seen as equivalents. However, the situation becomes more complicated when treatment timing varies [@Goodman-Bacon.2021].

::: {.callout-tip}
When estimating FE or Diff-in-Diff estimators, "*one should restrict the estimation sample to those persons who can potentially
experience the treatment during the observation window*". Usually this means that we start with the not-yet-treated and omit the already-treated [@Bruderl.2015].
:::




# Random Effects

## Random effects estimator

### The RE estimator

$$
y_{it} = \alpha + \beta x_{it} + \alpha_i + \vartheta_{it}.
$$

Instead of assuming $\alpha_i$ are fixed effects, we treat them as i.i.d random effects, usually assuming they are normally distributed


## Random effects estimator

The RE estimator has two main "advantages" over the FE estimator:

1) It is more efficient if $\E(\alpha_{i} | x_{it}) = 0$: it has lower standard errors 

2) It allows to estimate the effects of time-constant variables


## Random effects estimator

However, it obscures the main advantage of panel data: the relaxation of assumptions for consistency of estimators. The RE estimator needs the same assumptions as POLS for consistency:

* $\E(\alpha_{i} | x_{it}) = 0$: No time-constant unobserved heterogeneity

* $\E(\epsilon_{it} | x_{it}) = 0$: No time-varying unobserved heterogeneity


## Random effects estimator

We can also write the RE as a quasi-demeaned estimator:

$$
(y_{it} - \lambda\bar{y}_i) = \beta (x_{it} - \lambda\bar{x}_i) + (\epsilon_{it} - \lambda\bar{\epsilon}_i)  
$$

where $\hat{\lambda} = 1 - \sqrt{\frac{\sigma^2_\epsilon}{\sigma^2_\epsilon + T\sigma^2_\alpha}}$, with $\sigma^2_\epsilon$ denoting the residual variance, and $\sigma^2_\alpha$ denoting the variance of the individual effects $\alpha_i$.

## Random effects estimator

The RE (as POLS) is thus a weighted average of between and within estimator. The weights are determined by the residual variance in FE as share of total residual variance:

$$
\begin{split}
\beta_{RE} = \omega_{GLS} \beta_{FE} + (1-\omega_{GLS}) \beta_{BE},\\
\omega_{GLS} = \frac{\sigma^2_{\tilde{x}}}{\sigma^2_{\tilde{x}} + \phi^2 (\sigma^2_x-\sigma^2_{\tilde{x}})},\\
\phi = \sqrt{\frac{\hat{\sigma}^2_{FE}}{\hat{\sigma}^2_{BE}}},
\end{split}
$$

## Random effects estimator

It thus follows that:

* $T$ large, $\sigma^2_\alpha$ large, then RE $\rightarrow$ FE

* $\sigma^2_\alpha$ small, then RE $\rightarrow$ POLS

The RE uses all the available information - between and within variance - and weights the two components by its "predictive power". This makes it the most efficient estimator. 


## RE in `plm`

Let's estimate the RE for the happiness - age example, again using the `plm` package.

```{r}
#| echo: true
#| code-fold: true
#| output: false
#| #| code-line-numbers: "3"
re1 <- plm(happiness ~ age, data = df,
           index = c("id", "time"),
           effect = "individual", model = "random")
summary(re1)
```


## RE in `plm`

Let's estimate the RE for the happiness - age example, again using the `plm` package.

```{r}
#| echo: true
#| code-fold: true
#| output: true
#| #| code-line-numbers: "4"
re1 <- plm(happiness ~ age, data = df,
           index = c("id", "time"),
           effect = "individual", model = "random")
summary(re1)
```



## Equal weights of within and between

```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false

N <- 6
T <- 4
### Models
# Total line for plot
lm1 <- lm(happiness ~ age, data = df)
lm2 <- lm(happiness ~ age + cohort, data = df)
lm3 <- lm(happiness ~ age + idname, data = df)
lm4 <- lm(m_happiness ~ m_age, data = df)
re <- plm(happiness ~ age, df, model = "random", effect = "individual")

### Compare POLS, BE, FE, and RE
estimates <- data.frame(matrix(NA, ncol = 3, nrow = 4))
names(estimates) <- c("Model", "Intercept", "slope")
estimates[1,] <- c("POLS",
                   lm1$coefficients[1],
                   lm1$coefficients[2])
estimates[2,] <- c("BE",
                   lm4$coefficients[1], 
                   lm4$coefficients[2])
estimates[3,] <- c("FE",
                   lm3$coefficients[1] + 1/N * lm3$coefficients[3]  + 1/N * lm3$coefficients[4] 
                   + 1/N * lm3$coefficients[5]  + 1/N * lm3$coefficients[6]  + 1/N * lm3$coefficients[7], 
                   lm3$coefficients[2])
estimates[4,] <- c("RE",
                   re$coefficients[1], 
                   re$coefficients[2])
estimates[, -1] <- apply(estimates[, -1], 2, FUN = function(x) as.numeric(x))

newdf <- data.frame(matrix(NA, ncol = 2, nrow = 2))
names(newdf) <- c("x", "y")
newdf$x <- c(min(df$age), max(df$age))
for(i in 1:nrow(estimates)){
  newdf$y <- estimates[i, "Intercept"] + estimates[i, "slope"]*newdf$x
  newdf$Model <- estimates[i, "Model"]
  if(i == 1){
    pred <- newdf
  }else{pred <- rbind(pred, newdf)}
}

estimates$Model <- factor(estimates$Model, levels = c("POLS", "BE", "FE", "RE"))

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

zp6 <- ggplot(df, aes(age, happiness)) +
  geom_point(aes(x = age, y = happiness, shape = idname),
             colour = rep(gg_color_hue(6), each = T),
              size = 2, stroke = 1, show.legend = FALSE) +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE, show.legend = FALSE,
              linetype = "dashed", aes(group = idname), colour = alpha("gray", 1)) +
  geom_point(data = unique(df[, c("m_age", "m_happiness", "idname")]),
             aes(x = m_age, y = m_happiness, shape = idname),
             colour = gg_color_hue(6), alpha = 0.5,
              size = 3, stroke = 2, show.legend = FALSE) +
  scale_fill_manual(values = cbp2[-c(1, 2)]) +
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  geom_abline(data = estimates, lwd = 1.2,
              mapping = aes(intercept = Intercept, slope = slope, 
                            colour = Model, linetype = Model)) +
  scale_linetype_manual(values = c("solid", "twodash", "longdash", "dotdash")) +
  scale_color_viridis(discrete = TRUE, option = "D")+
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  theme_classic() +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.95,0.05), legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"),
        plot.title = element_text(hjust = 0.5))
zp6
```


## Increasing T


```{r}
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
N <- 6
T <- 8

set.seed(123)
df <- simdata(N = N, T = T, uw_sd = 0, age_range = c(20:60))

### Models
# Total line for plot
lm1 <- lm(happiness ~ age, data = df)
lm2 <- lm(happiness ~ age + cohort, data = df)
lm3 <- lm(happiness ~ age + idname, data = df)
lm4 <- lm(m_happiness ~ m_age, data = df)
re <- plm(happiness ~ age, df, model = "random", effect = "individual")

### Compare POLS, BE, FE, and RE
estimates <- data.frame(matrix(NA, ncol = 3, nrow = 4))
names(estimates) <- c("Model", "Intercept", "slope")
estimates[1,] <- c("POLS",
                   lm1$coefficients[1],
                   lm1$coefficients[2])
estimates[2,] <- c("BE",
                   lm4$coefficients[1], 
                   lm4$coefficients[2])
estimates[3,] <- c("FE",
                   lm3$coefficients[1] + 1/N * lm3$coefficients[3]  + 1/N * lm3$coefficients[4] 
                   + 1/N * lm3$coefficients[5]  + 1/N * lm3$coefficients[6]  + 1/N * lm3$coefficients[7], 
                   lm3$coefficients[2])
estimates[4,] <- c("RE",
                   re$coefficients[1], 
                   re$coefficients[2])
estimates[, -1] <- apply(estimates[, -1], 2, FUN = function(x) as.numeric(x))

newdf <- data.frame(matrix(NA, ncol = 2, nrow = 2))
names(newdf) <- c("x", "y")
newdf$x <- c(min(df$age), max(df$age))
for(i in 1:nrow(estimates)){
  newdf$y <- estimates[i, "Intercept"] + estimates[i, "slope"]*newdf$x
  newdf$Model <- estimates[i, "Model"]
  if(i == 1){
    pred <- newdf
  }else{pred <- rbind(pred, newdf)}
}

estimates$Model <- factor(estimates$Model, levels = c("POLS", "BE", "FE", "RE"))

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

zp7 <- ggplot(df, aes(age, happiness)) +
  geom_point(aes(x = age, y = happiness, shape = idname),
             colour = rep(gg_color_hue(6), each = T),
              size = 2, stroke = 1, show.legend = FALSE) +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE, show.legend = FALSE,
              linetype = "dashed", aes(group = idname), colour = alpha("gray", 1)) +
  geom_point(data = unique(df[, c("m_age", "m_happiness", "idname")]),
             aes(x = m_age, y = m_happiness, shape = idname),
             colour = gg_color_hue(6), alpha = 0.5,
              size = 3, stroke = 2, show.legend = FALSE) +
  scale_fill_manual(values = cbp2[-c(1, 2)]) +
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  geom_abline(data = estimates, lwd = 1.2,
              mapping = aes(intercept = Intercept, slope = slope, 
                            colour = Model, linetype = Model)) +
  scale_linetype_manual(values = c("solid", "twodash", "longdash", "dotdash")) +
  scale_color_viridis(discrete = TRUE, option = "D")+
  scale_linetype_manual(values = c("solid", "twodash", "longdash", "dotdash")) +
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  theme_classic() +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.95,0.05), legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"),
        plot.title = element_text(hjust = 0.5))
zp7
```


## Increasing the within-unit noise

```{r }
#| echo: true
#| code-fold: true
#| message: false
#| warning: false
N <- 6
T <- 8

set.seed(123)
df <- simdata(N = N, T = T, uw_sd = 0.5, age_range = c(20:60))

### Models
# Total line for plot
lm1 <- lm(happiness ~ age, data = df)
lm2 <- lm(happiness ~ age + cohort, data = df)
lm3 <- lm(happiness ~ age + idname, data = df)
lm4 <- lm(m_happiness ~ m_age, data = df)
re <- plm(happiness ~ age, df, model = "random", effect = "individual")

### Compare POLS, BE, FE, and RE
estimates <- data.frame(matrix(NA, ncol = 3, nrow = 4))
names(estimates) <- c("Model", "Intercept", "slope")
estimates[1,] <- c("POLS",
                   lm1$coefficients[1],
                   lm1$coefficients[2])
estimates[2,] <- c("BE",
                   lm4$coefficients[1], 
                   lm4$coefficients[2])
estimates[3,] <- c("FE",
                   lm3$coefficients[1] + 1/N * lm3$coefficients[3]  + 1/N * lm3$coefficients[4] 
                   + 1/N * lm3$coefficients[5]  + 1/N * lm3$coefficients[6]  + 1/N * lm3$coefficients[7], 
                   lm3$coefficients[2])
estimates[4,] <- c("RE",
                   re$coefficients[1], 
                   re$coefficients[2])
estimates[, -1] <- apply(estimates[, -1], 2, FUN = function(x) as.numeric(x))

newdf <- data.frame(matrix(NA, ncol = 2, nrow = 2))
names(newdf) <- c("x", "y")
newdf$x <- c(min(df$age), max(df$age))
for(i in 1:nrow(estimates)){
  newdf$y <- estimates[i, "Intercept"] + estimates[i, "slope"]*newdf$x
  newdf$Model <- estimates[i, "Model"]
  if(i == 1){
    pred <- newdf
  }else{pred <- rbind(pred, newdf)}
}

estimates$Model <- factor(estimates$Model, levels = c("POLS", "BE", "FE", "RE"))

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

zp7 <- ggplot(df, aes(age, happiness)) +
  geom_point(aes(x = age, y = happiness, shape = idname),
             colour = rep(gg_color_hue(6), each = T),
              size = 2, stroke = 1, show.legend = FALSE) +
  geom_smooth(method = 'lm', formula = y ~ x, se = FALSE, show.legend = FALSE,
              linetype = "dashed", aes(group = idname), colour = alpha("gray", 1)) +
  geom_point(data = unique(df[, c("m_age", "m_happiness", "idname")]),
             aes(x = m_age, y = m_happiness, shape = idname),
             colour = gg_color_hue(6), alpha = 0.5,
              size = 3, stroke = 2, show.legend = FALSE) +
  scale_fill_manual(values = cbp2[-c(1, 2)]) +
  scale_colour_manual(values = cbp2[-c(1, 2)]) + 
  scale_shape_manual(values = c(15:18, 25, 20)) +
  geom_abline(data = estimates, lwd = 1.2,
              mapping = aes(intercept = Intercept, slope = slope, 
                            colour = Model, linetype = Model)) +
  scale_linetype_manual(values = c("solid", "twodash", "longdash", "dotdash")) +
  scale_color_viridis(discrete = TRUE, option = "D")+
  ylim(3.3, 9.2) + expand_limits(y = c(0, 0)) + 
  theme_classic() +
  theme(legend.key = element_blank(), legend.title = element_blank(),
        legend.position = c(0.95,0.05), legend.justification = c("right", "bottom"),
        legend.background = element_blank(),
        legend.box.background = element_rect(colour = "black"),
        plot.title = element_text(hjust = 0.5))
zp7
```



## References

